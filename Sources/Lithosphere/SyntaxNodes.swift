/// SyntaxNodes.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017-2019, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
// swiftlint:disable line_length
// swiftlint:disable function_parameter_count
// swiftlint:disable trailing_whitespace

/// A wrapper around a raw Syntax layout.
public struct UnknownSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  /// Creates an `UnknownSyntax` node from the provided root and data.
  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
}

public protocol DeclSyntax: Syntax {}
public protocol ExprSyntax: Syntax {}
public protocol TypedParameterSyntax: Syntax {}
public protocol FunctionClauseDeclSyntax: DeclSyntax {}
public protocol FixityDeclSyntax: DeclSyntax {}
public protocol BindingSyntax: Syntax {}
public protocol BasicExprSyntax: ExprSyntax {}
public struct SourceFileSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new SourceFileSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> SourceFileSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return SourceFileSyntax(root: newRoot, data: newData)
  }

  /// Creates a new SourceFileSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: TokenSyntax) -> SourceFileSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new SourceFileSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: TokenSyntax) -> SourceFileSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new SourceFileSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new SourceFileSyntax with that element appended to the end.
  public func inserting(_ syntax: TokenSyntax,
                        at index: Int) -> SourceFileSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new SourceFileSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new SourceFileSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> SourceFileSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new SourceFileSyntax by removing the first element.
  ///
  /// - Returns: A new SourceFileSyntax with the first element removed.
  public func removingFirst() -> SourceFileSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new SourceFileSyntax by removing the last element.
  ///
  /// - Returns: A new SourceFileSyntax with the last element removed.
  public func removingLast() -> SourceFileSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> SourceFileSyntaxIterator {
    return SourceFileSyntaxIterator(collection: self)
  }
}

/// Conformance for SourceFileSyntax to the Collection protocol.
extension SourceFileSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> TokenSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! TokenSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct SourceFileSyntaxIterator: IteratorProtocol {
  private let collection: SourceFileSyntax
  private var index: SourceFileSyntax.Index

  fileprivate init(collection: SourceFileSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> TokenSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct IdentifierListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new IdentifierListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> IdentifierListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return IdentifierListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new IdentifierListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: TokenSyntax) -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: TokenSyntax) -> IdentifierListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new IdentifierListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new IdentifierListSyntax with that element appended to the end.
  public func inserting(_ syntax: TokenSyntax,
                        at index: Int) -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new IdentifierListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by removing the first element.
  ///
  /// - Returns: A new IdentifierListSyntax with the first element removed.
  public func removingFirst() -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new IdentifierListSyntax by removing the last element.
  ///
  /// - Returns: A new IdentifierListSyntax with the last element removed.
  public func removingLast() -> IdentifierListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> IdentifierListSyntaxIterator {
    return IdentifierListSyntaxIterator(collection: self)
  }
}

/// Conformance for IdentifierListSyntax to the Collection protocol.
extension IdentifierListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> TokenSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! TokenSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct IdentifierListSyntaxIterator: IteratorProtocol {
  private let collection: IdentifierListSyntax
  private var index: IdentifierListSyntax.Index

  fileprivate init(collection: IdentifierListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> TokenSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct QualifiedNameSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new QualifiedNameSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> QualifiedNameSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return QualifiedNameSyntax(root: newRoot, data: newData)
  }

  /// Creates a new QualifiedNameSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: QualifiedNamePieceSyntax) -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: QualifiedNamePieceSyntax) -> QualifiedNameSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new QualifiedNameSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new QualifiedNameSyntax with that element appended to the end.
  public func inserting(_ syntax: QualifiedNamePieceSyntax,
                        at index: Int) -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new QualifiedNameSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by removing the first element.
  ///
  /// - Returns: A new QualifiedNameSyntax with the first element removed.
  public func removingFirst() -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new QualifiedNameSyntax by removing the last element.
  ///
  /// - Returns: A new QualifiedNameSyntax with the last element removed.
  public func removingLast() -> QualifiedNameSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> QualifiedNameSyntaxIterator {
    return QualifiedNameSyntaxIterator(collection: self)
  }
}

/// Conformance for QualifiedNameSyntax to the Collection protocol.
extension QualifiedNameSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> QualifiedNamePieceSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! QualifiedNamePieceSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct QualifiedNameSyntaxIterator: IteratorProtocol {
  private let collection: QualifiedNameSyntax
  private var index: QualifiedNameSyntax.Index

  fileprivate init(collection: QualifiedNameSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> QualifiedNamePieceSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct QualifiedNamePieceSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case name
    case trailingPeriod
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var name: TokenSyntax {
    let child = data.cachedChild(at: Cursor.name.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withName(_ newChild: TokenSyntax) -> QualifiedNamePieceSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return QualifiedNamePieceSyntax(root: root, data: newData)
  }

  public var trailingPeriod: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingPeriod.rawValue)
    if child == nil { return nil }
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
  public func withTrailingPeriod(_ newChild: TokenSyntax?) -> QualifiedNamePieceSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(.period)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingPeriod)
    return QualifiedNamePieceSyntax(root: root, data: newData)
  }

}

public struct ModuleDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case moduleToken
    case moduleIdentifier
    case typedParameterList
    case whereToken
    case leftBraceToken
    case declList
    case rightBraceToken
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var moduleToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.moduleToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withModuleToken(_ newChild: TokenSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.moduleToken)
    return ModuleDeclSyntax(root: root, data: newData)
  }

  public var moduleIdentifier: QualifiedNameSyntax {
    let child = data.cachedChild(at: Cursor.moduleIdentifier.rawValue)

    return makeSyntax(root: _root, data: child!) as! QualifiedNameSyntax
  }
  public func withModuleIdentifier(_ newChild: QualifiedNameSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.moduleIdentifier)
    return ModuleDeclSyntax(root: root, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    let child = data.cachedChild(at: Cursor.typedParameterList.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ newChild: TypedParameterListSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typedParameterList)
    return ModuleDeclSyntax(root: root, data: newData)
  }

  public var whereToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whereToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withWhereToken(_ newChild: TokenSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereToken)
    return ModuleDeclSyntax(root: root, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftBraceToken(_ newChild: TokenSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBraceToken)
    return ModuleDeclSyntax(root: root, data: newData)
  }

  public var declList: DeclListSyntax {
    let child = data.cachedChild(at: Cursor.declList.rawValue)

    return makeSyntax(root: _root, data: child!) as! DeclListSyntax
  }
  public func withDeclList(_ newChild: DeclListSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declList)
    return ModuleDeclSyntax(root: root, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightBraceToken(_ newChild: TokenSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBraceToken)
    return ModuleDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> ModuleDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return ModuleDeclSyntax(root: root, data: newData)
  }

}

public struct DeclListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new DeclListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> DeclListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return DeclListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new DeclListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: DeclSyntax) -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: DeclSyntax) -> DeclListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new DeclListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new DeclListSyntax with that element appended to the end.
  public func inserting(_ syntax: DeclSyntax,
                        at index: Int) -> DeclListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new DeclListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by removing the first element.
  ///
  /// - Returns: A new DeclListSyntax with the first element removed.
  public func removingFirst() -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new DeclListSyntax by removing the last element.
  ///
  /// - Returns: A new DeclListSyntax with the last element removed.
  public func removingLast() -> DeclListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> DeclListSyntaxIterator {
    return DeclListSyntaxIterator(collection: self)
  }
}

/// Conformance for DeclListSyntax to the Collection protocol.
extension DeclListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> DeclSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! DeclSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct DeclListSyntaxIterator: IteratorProtocol {
  private let collection: DeclListSyntax
  private var index: DeclListSyntax.Index

  fileprivate init(collection: DeclListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> DeclSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct OpenImportDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case openToken
    case importToken
    case importIdentifier
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var openToken: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.openToken.rawValue)
    if child == nil { return nil }
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
  public func withOpenToken(_ newChild: TokenSyntax?) -> OpenImportDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(.openKeyword)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.openToken)
    return OpenImportDeclSyntax(root: root, data: newData)
  }

  public var importToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.importToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withImportToken(_ newChild: TokenSyntax) -> OpenImportDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.importToken)
    return OpenImportDeclSyntax(root: root, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    let child = data.cachedChild(at: Cursor.importIdentifier.rawValue)

    return makeSyntax(root: _root, data: child!) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ newChild: QualifiedNameSyntax) -> OpenImportDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.importIdentifier)
    return OpenImportDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> OpenImportDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return OpenImportDeclSyntax(root: root, data: newData)
  }

}

public struct ImportDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case importToken
    case importIdentifier
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var importToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.importToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withImportToken(_ newChild: TokenSyntax) -> ImportDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.importToken)
    return ImportDeclSyntax(root: root, data: newData)
  }

  public var importIdentifier: QualifiedNameSyntax {
    let child = data.cachedChild(at: Cursor.importIdentifier.rawValue)

    return makeSyntax(root: _root, data: child!) as! QualifiedNameSyntax
  }
  public func withImportIdentifier(_ newChild: QualifiedNameSyntax) -> ImportDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.importIdentifier)
    return ImportDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> ImportDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return ImportDeclSyntax(root: root, data: newData)
  }

}

public struct DataDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case whereToken
    case leftBraceToken
    case constructorList
    case rightBraceToken
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var dataToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.dataToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withDataToken(_ newChild: TokenSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dataToken)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var dataIdentifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.dataIdentifier.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withDataIdentifier(_ newChild: TokenSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dataIdentifier)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    let child = data.cachedChild(at: Cursor.typedParameterList.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ newChild: TypedParameterListSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typedParameterList)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    let child = data.cachedChild(at: Cursor.typeIndices.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ newChild: TypeIndicesSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeIndices)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var whereToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whereToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withWhereToken(_ newChild: TokenSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereToken)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftBraceToken(_ newChild: TokenSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBraceToken)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var constructorList: ConstructorListSyntax {
    let child = data.cachedChild(at: Cursor.constructorList.rawValue)

    return makeSyntax(root: _root, data: child!) as! ConstructorListSyntax
  }
  public func withConstructorList(_ newChild: ConstructorListSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.constructorList)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightBraceToken(_ newChild: TokenSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBraceToken)
    return DataDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> DataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return DataDeclSyntax(root: root, data: newData)
  }

}

public struct EmptyDataDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case dataToken
    case dataIdentifier
    case typedParameterList
    case typeIndices
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var dataToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.dataToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withDataToken(_ newChild: TokenSyntax) -> EmptyDataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dataToken)
    return EmptyDataDeclSyntax(root: root, data: newData)
  }

  public var dataIdentifier: TokenSyntax {
    let child = data.cachedChild(at: Cursor.dataIdentifier.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withDataIdentifier(_ newChild: TokenSyntax) -> EmptyDataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.dataIdentifier)
    return EmptyDataDeclSyntax(root: root, data: newData)
  }

  public var typedParameterList: TypedParameterListSyntax {
    let child = data.cachedChild(at: Cursor.typedParameterList.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypedParameterListSyntax
  }
  public func withTypedParameterList(_ newChild: TypedParameterListSyntax) -> EmptyDataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typedParameterList)
    return EmptyDataDeclSyntax(root: root, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    let child = data.cachedChild(at: Cursor.typeIndices.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ newChild: TypeIndicesSyntax) -> EmptyDataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeIndices)
    return EmptyDataDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> EmptyDataDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return EmptyDataDeclSyntax(root: root, data: newData)
  }

}

public struct TypeIndicesSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case colonToken
    case indexExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var colonToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colonToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withColonToken(_ newChild: TokenSyntax) -> TypeIndicesSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colonToken)
    return TypeIndicesSyntax(root: root, data: newData)
  }

  public var indexExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.indexExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withIndexExpr(_ newChild: ExprSyntax) -> TypeIndicesSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.indexExpr)
    return TypeIndicesSyntax(root: root, data: newData)
  }

}

public struct TypedParameterListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new TypedParameterListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> TypedParameterListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return TypedParameterListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new TypedParameterListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: TypedParameterSyntax) -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: TypedParameterSyntax) -> TypedParameterListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new TypedParameterListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new TypedParameterListSyntax with that element appended to the end.
  public func inserting(_ syntax: TypedParameterSyntax,
                        at index: Int) -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new TypedParameterListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by removing the first element.
  ///
  /// - Returns: A new TypedParameterListSyntax with the first element removed.
  public func removingFirst() -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new TypedParameterListSyntax by removing the last element.
  ///
  /// - Returns: A new TypedParameterListSyntax with the last element removed.
  public func removingLast() -> TypedParameterListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> TypedParameterListSyntaxIterator {
    return TypedParameterListSyntaxIterator(collection: self)
  }
}

/// Conformance for TypedParameterListSyntax to the Collection protocol.
extension TypedParameterListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> TypedParameterSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! TypedParameterSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct TypedParameterListSyntaxIterator: IteratorProtocol {
  private let collection: TypedParameterListSyntax
  private var index: TypedParameterListSyntax.Index

  fileprivate init(collection: TypedParameterListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> TypedParameterSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct AscriptionSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case boundNames
    case colonToken
    case typeExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var boundNames: IdentifierListSyntax {
    let child = data.cachedChild(at: Cursor.boundNames.rawValue)

    return makeSyntax(root: _root, data: child!) as! IdentifierListSyntax
  }
  public func withBoundNames(_ newChild: IdentifierListSyntax) -> AscriptionSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.boundNames)
    return AscriptionSyntax(root: root, data: newData)
  }

  public var colonToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.colonToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withColonToken(_ newChild: TokenSyntax) -> AscriptionSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.colonToken)
    return AscriptionSyntax(root: root, data: newData)
  }

  public var typeExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.typeExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withTypeExpr(_ newChild: ExprSyntax) -> AscriptionSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeExpr)
    return AscriptionSyntax(root: root, data: newData)
  }

}

public struct ExplicitTypedParameterSyntax: TypedParameterSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case leftParenToken
    case ascription
    case rightParenToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var leftParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftParenToken(_ newChild: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParenToken)
    return ExplicitTypedParameterSyntax(root: root, data: newData)
  }

  public var ascription: AscriptionSyntax {
    let child = data.cachedChild(at: Cursor.ascription.rawValue)

    return makeSyntax(root: _root, data: child!) as! AscriptionSyntax
  }
  public func withAscription(_ newChild: AscriptionSyntax) -> ExplicitTypedParameterSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ascription)
    return ExplicitTypedParameterSyntax(root: root, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightParenToken(_ newChild: TokenSyntax) -> ExplicitTypedParameterSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParenToken)
    return ExplicitTypedParameterSyntax(root: root, data: newData)
  }

}

public struct ImplicitTypedParameterSyntax: TypedParameterSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case leftBraceToken
    case ascription
    case rightBraceToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var leftBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftBraceToken(_ newChild: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBraceToken)
    return ImplicitTypedParameterSyntax(root: root, data: newData)
  }

  public var ascription: AscriptionSyntax {
    let child = data.cachedChild(at: Cursor.ascription.rawValue)

    return makeSyntax(root: _root, data: child!) as! AscriptionSyntax
  }
  public func withAscription(_ newChild: AscriptionSyntax) -> ImplicitTypedParameterSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ascription)
    return ImplicitTypedParameterSyntax(root: root, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightBraceToken(_ newChild: TokenSyntax) -> ImplicitTypedParameterSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBraceToken)
    return ImplicitTypedParameterSyntax(root: root, data: newData)
  }

}

public struct ConstructorListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new ConstructorListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> ConstructorListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return ConstructorListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new ConstructorListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: ConstructorDeclSyntax) -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: ConstructorDeclSyntax) -> ConstructorListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new ConstructorListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new ConstructorListSyntax with that element appended to the end.
  public func inserting(_ syntax: ConstructorDeclSyntax,
                        at index: Int) -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new ConstructorListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by removing the first element.
  ///
  /// - Returns: A new ConstructorListSyntax with the first element removed.
  public func removingFirst() -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new ConstructorListSyntax by removing the last element.
  ///
  /// - Returns: A new ConstructorListSyntax with the last element removed.
  public func removingLast() -> ConstructorListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> ConstructorListSyntaxIterator {
    return ConstructorListSyntaxIterator(collection: self)
  }
}

/// Conformance for ConstructorListSyntax to the Collection protocol.
extension ConstructorListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> ConstructorDeclSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! ConstructorDeclSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct ConstructorListSyntaxIterator: IteratorProtocol {
  private let collection: ConstructorListSyntax
  private var index: ConstructorListSyntax.Index

  fileprivate init(collection: ConstructorListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> ConstructorDeclSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct ConstructorDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var ascription: AscriptionSyntax {
    let child = data.cachedChild(at: Cursor.ascription.rawValue)

    return makeSyntax(root: _root, data: child!) as! AscriptionSyntax
  }
  public func withAscription(_ newChild: AscriptionSyntax) -> ConstructorDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ascription)
    return ConstructorDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> ConstructorDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return ConstructorDeclSyntax(root: root, data: newData)
  }

}

public struct RecordDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case recordToken
    case recordName
    case parameterList
    case typeIndices
    case whereToken
    case leftParenToken
    case recordElementList
    case rightParenToken
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var recordToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.recordToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRecordToken(_ newChild: TokenSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.recordToken)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var recordName: TokenSyntax {
    let child = data.cachedChild(at: Cursor.recordName.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRecordName(_ newChild: TokenSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.recordName)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var parameterList: TypedParameterListSyntax {
    let child = data.cachedChild(at: Cursor.parameterList.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypedParameterListSyntax
  }
  public func withParameterList(_ newChild: TypedParameterListSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.parameterList)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var typeIndices: TypeIndicesSyntax {
    let child = data.cachedChild(at: Cursor.typeIndices.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypeIndicesSyntax
  }
  public func withTypeIndices(_ newChild: TypeIndicesSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeIndices)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var whereToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whereToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withWhereToken(_ newChild: TokenSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereToken)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var leftParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftParenToken(_ newChild: TokenSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParenToken)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var recordElementList: DeclListSyntax {
    let child = data.cachedChild(at: Cursor.recordElementList.rawValue)

    return makeSyntax(root: _root, data: child!) as! DeclListSyntax
  }
  public func withRecordElementList(_ newChild: DeclListSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.recordElementList)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightParenToken(_ newChild: TokenSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParenToken)
    return RecordDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> RecordDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return RecordDeclSyntax(root: root, data: newData)
  }

}

public struct FieldDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case fieldToken
    case ascription
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var fieldToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.fieldToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withFieldToken(_ newChild: TokenSyntax) -> FieldDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fieldToken)
    return FieldDeclSyntax(root: root, data: newData)
  }

  public var ascription: AscriptionSyntax {
    let child = data.cachedChild(at: Cursor.ascription.rawValue)

    return makeSyntax(root: _root, data: child!) as! AscriptionSyntax
  }
  public func withAscription(_ newChild: AscriptionSyntax) -> FieldDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ascription)
    return FieldDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> FieldDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return FieldDeclSyntax(root: root, data: newData)
  }

}

public struct RecordConstructorDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case constructorToken
    case constructorName
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var constructorToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.constructorToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withConstructorToken(_ newChild: TokenSyntax) -> RecordConstructorDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.constructorToken)
    return RecordConstructorDeclSyntax(root: root, data: newData)
  }

  public var constructorName: TokenSyntax {
    let child = data.cachedChild(at: Cursor.constructorName.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withConstructorName(_ newChild: TokenSyntax) -> RecordConstructorDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.constructorName)
    return RecordConstructorDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> RecordConstructorDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return RecordConstructorDeclSyntax(root: root, data: newData)
  }

}

public struct RecordFieldAssignmentListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new RecordFieldAssignmentListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> RecordFieldAssignmentListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return RecordFieldAssignmentListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: RecordFieldAssignmentSyntax) -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: RecordFieldAssignmentSyntax) -> RecordFieldAssignmentListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new RecordFieldAssignmentListSyntax with that element appended to the end.
  public func inserting(_ syntax: RecordFieldAssignmentSyntax,
                        at index: Int) -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new RecordFieldAssignmentListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by removing the first element.
  ///
  /// - Returns: A new RecordFieldAssignmentListSyntax with the first element removed.
  public func removingFirst() -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new RecordFieldAssignmentListSyntax by removing the last element.
  ///
  /// - Returns: A new RecordFieldAssignmentListSyntax with the last element removed.
  public func removingLast() -> RecordFieldAssignmentListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> RecordFieldAssignmentListSyntaxIterator {
    return RecordFieldAssignmentListSyntaxIterator(collection: self)
  }
}

/// Conformance for RecordFieldAssignmentListSyntax to the Collection protocol.
extension RecordFieldAssignmentListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> RecordFieldAssignmentSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! RecordFieldAssignmentSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct RecordFieldAssignmentListSyntaxIterator: IteratorProtocol {
  private let collection: RecordFieldAssignmentListSyntax
  private var index: RecordFieldAssignmentListSyntax.Index

  fileprivate init(collection: RecordFieldAssignmentListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> RecordFieldAssignmentSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct RecordFieldAssignmentSyntax: Syntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case fieldName
    case equalsToken
    case fieldInitExpr
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var fieldName: TokenSyntax {
    let child = data.cachedChild(at: Cursor.fieldName.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withFieldName(_ newChild: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fieldName)
    return RecordFieldAssignmentSyntax(root: root, data: newData)
  }

  public var equalsToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.equalsToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withEqualsToken(_ newChild: TokenSyntax) -> RecordFieldAssignmentSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.equalsToken)
    return RecordFieldAssignmentSyntax(root: root, data: newData)
  }

  public var fieldInitExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.fieldInitExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withFieldInitExpr(_ newChild: ExprSyntax) -> RecordFieldAssignmentSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fieldInitExpr)
    return RecordFieldAssignmentSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax? {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)
    if child == nil { return nil }
    return makeSyntax(root: _root, data: child!) as? TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax?) -> RecordFieldAssignmentSyntax {
    let raw = newChild?.raw ?? RawSyntax.missingToken(.semicolon)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return RecordFieldAssignmentSyntax(root: root, data: newData)
  }

}

public struct FunctionDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case ascription
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var ascription: AscriptionSyntax {
    let child = data.cachedChild(at: Cursor.ascription.rawValue)

    return makeSyntax(root: _root, data: child!) as! AscriptionSyntax
  }
  public func withAscription(_ newChild: AscriptionSyntax) -> FunctionDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.ascription)
    return FunctionDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> FunctionDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return FunctionDeclSyntax(root: root, data: newData)
  }

}

public struct WithRuleFunctionClauseDeclSyntax: FunctionClauseDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case basicExprList
    case withToken
    case withExpr
    case withPatternClause
    case equalsToken
    case rhsExpr
    case whereClause
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var basicExprList: BasicExprListSyntax {
    let child = data.cachedChild(at: Cursor.basicExprList.rawValue)

    return makeSyntax(root: _root, data: child!) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ newChild: BasicExprListSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.basicExprList)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var withToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.withToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withWithToken(_ newChild: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.withToken)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var withExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.withExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withWithExpr(_ newChild: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.withExpr)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var withPatternClause: BasicExprListSyntax? {
    let child = data.cachedChild(at: Cursor.withPatternClause.rawValue)
    if child == nil { return nil }
    return makeSyntax(root: _root, data: child!) as? BasicExprListSyntax
  }
  public func withWithPatternClause(_ newChild: BasicExprListSyntax?) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(.basicExprList)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.withPatternClause)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var equalsToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.equalsToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withEqualsToken(_ newChild: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.equalsToken)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.rhsExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withRhsExpr(_ newChild: ExprSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rhsExpr)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var whereClause: FunctionWhereClauseDeclSyntax? {
    let child = data.cachedChild(at: Cursor.whereClause.rawValue)
    if child == nil { return nil }
    return makeSyntax(root: _root, data: child!) as? FunctionWhereClauseDeclSyntax
  }
  public func withWhereClause(_ newChild: FunctionWhereClauseDeclSyntax?) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(.functionWhereClauseDecl)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereClause)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> WithRuleFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return WithRuleFunctionClauseDeclSyntax(root: root, data: newData)
  }

}

public struct NormalFunctionClauseDeclSyntax: FunctionClauseDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case basicExprList
    case equalsToken
    case rhsExpr
    case whereClause
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var basicExprList: BasicExprListSyntax {
    let child = data.cachedChild(at: Cursor.basicExprList.rawValue)

    return makeSyntax(root: _root, data: child!) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ newChild: BasicExprListSyntax) -> NormalFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.basicExprList)
    return NormalFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var equalsToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.equalsToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withEqualsToken(_ newChild: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.equalsToken)
    return NormalFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var rhsExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.rhsExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withRhsExpr(_ newChild: ExprSyntax) -> NormalFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rhsExpr)
    return NormalFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var whereClause: FunctionWhereClauseDeclSyntax? {
    let child = data.cachedChild(at: Cursor.whereClause.rawValue)
    if child == nil { return nil }
    return makeSyntax(root: _root, data: child!) as? FunctionWhereClauseDeclSyntax
  }
  public func withWhereClause(_ newChild: FunctionWhereClauseDeclSyntax?) -> NormalFunctionClauseDeclSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(.functionWhereClauseDecl)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereClause)
    return NormalFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> NormalFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return NormalFunctionClauseDeclSyntax(root: root, data: newData)
  }

}

public struct AbsurdFunctionClauseDeclSyntax: FunctionClauseDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case basicExprList
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var basicExprList: BasicExprListSyntax {
    let child = data.cachedChild(at: Cursor.basicExprList.rawValue)

    return makeSyntax(root: _root, data: child!) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ newChild: BasicExprListSyntax) -> AbsurdFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.basicExprList)
    return AbsurdFunctionClauseDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> AbsurdFunctionClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return AbsurdFunctionClauseDeclSyntax(root: root, data: newData)
  }

}

public struct FunctionWhereClauseDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case whereToken
    case leftBraceToken
    case declList
    case rightBraceToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var whereToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.whereToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withWhereToken(_ newChild: TokenSyntax) -> FunctionWhereClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.whereToken)
    return FunctionWhereClauseDeclSyntax(root: root, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftBraceToken(_ newChild: TokenSyntax) -> FunctionWhereClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBraceToken)
    return FunctionWhereClauseDeclSyntax(root: root, data: newData)
  }

  public var declList: DeclListSyntax {
    let child = data.cachedChild(at: Cursor.declList.rawValue)

    return makeSyntax(root: _root, data: child!) as! DeclListSyntax
  }
  public func withDeclList(_ newChild: DeclListSyntax) -> FunctionWhereClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declList)
    return FunctionWhereClauseDeclSyntax(root: root, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightBraceToken(_ newChild: TokenSyntax) -> FunctionWhereClauseDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBraceToken)
    return FunctionWhereClauseDeclSyntax(root: root, data: newData)
  }

}

public struct LetBindingDeclSyntax: DeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case head
    case basicExprList
    case equalsToken
    case boundExpr
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var head: NamedBasicExprSyntax {
    let child = data.cachedChild(at: Cursor.head.rawValue)

    return makeSyntax(root: _root, data: child!) as! NamedBasicExprSyntax
  }
  public func withHead(_ newChild: NamedBasicExprSyntax) -> LetBindingDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.head)
    return LetBindingDeclSyntax(root: root, data: newData)
  }

  public var basicExprList: BasicExprListSyntax {
    let child = data.cachedChild(at: Cursor.basicExprList.rawValue)

    return makeSyntax(root: _root, data: child!) as! BasicExprListSyntax
  }
  public func withBasicExprList(_ newChild: BasicExprListSyntax) -> LetBindingDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.basicExprList)
    return LetBindingDeclSyntax(root: root, data: newData)
  }

  public var equalsToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.equalsToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withEqualsToken(_ newChild: TokenSyntax) -> LetBindingDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.equalsToken)
    return LetBindingDeclSyntax(root: root, data: newData)
  }

  public var boundExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.boundExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withBoundExpr(_ newChild: ExprSyntax) -> LetBindingDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.boundExpr)
    return LetBindingDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> LetBindingDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return LetBindingDeclSyntax(root: root, data: newData)
  }

}

public struct NonFixDeclSyntax: FixityDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case infixToken
    case precedence
    case names
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var infixToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.infixToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withInfixToken(_ newChild: TokenSyntax) -> NonFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.infixToken)
    return NonFixDeclSyntax(root: root, data: newData)
  }

  public var precedence: TokenSyntax {
    let child = data.cachedChild(at: Cursor.precedence.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withPrecedence(_ newChild: TokenSyntax) -> NonFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.precedence)
    return NonFixDeclSyntax(root: root, data: newData)
  }

  public var names: IdentifierListSyntax {
    let child = data.cachedChild(at: Cursor.names.rawValue)

    return makeSyntax(root: _root, data: child!) as! IdentifierListSyntax
  }
  public func withNames(_ newChild: IdentifierListSyntax) -> NonFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.names)
    return NonFixDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> NonFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return NonFixDeclSyntax(root: root, data: newData)
  }

}

public struct LeftFixDeclSyntax: FixityDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case infixlToken
    case precedence
    case names
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var infixlToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.infixlToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withInfixlToken(_ newChild: TokenSyntax) -> LeftFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.infixlToken)
    return LeftFixDeclSyntax(root: root, data: newData)
  }

  public var precedence: TokenSyntax {
    let child = data.cachedChild(at: Cursor.precedence.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withPrecedence(_ newChild: TokenSyntax) -> LeftFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.precedence)
    return LeftFixDeclSyntax(root: root, data: newData)
  }

  public var names: IdentifierListSyntax {
    let child = data.cachedChild(at: Cursor.names.rawValue)

    return makeSyntax(root: _root, data: child!) as! IdentifierListSyntax
  }
  public func withNames(_ newChild: IdentifierListSyntax) -> LeftFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.names)
    return LeftFixDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> LeftFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return LeftFixDeclSyntax(root: root, data: newData)
  }

}

public struct RightFixDeclSyntax: FixityDeclSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case infixrToken
    case precedence
    case names
    case trailingSemicolon
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var infixrToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.infixrToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withInfixrToken(_ newChild: TokenSyntax) -> RightFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.infixrToken)
    return RightFixDeclSyntax(root: root, data: newData)
  }

  public var precedence: TokenSyntax {
    let child = data.cachedChild(at: Cursor.precedence.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withPrecedence(_ newChild: TokenSyntax) -> RightFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.precedence)
    return RightFixDeclSyntax(root: root, data: newData)
  }

  public var names: IdentifierListSyntax {
    let child = data.cachedChild(at: Cursor.names.rawValue)

    return makeSyntax(root: _root, data: child!) as! IdentifierListSyntax
  }
  public func withNames(_ newChild: IdentifierListSyntax) -> RightFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.names)
    return RightFixDeclSyntax(root: root, data: newData)
  }

  public var trailingSemicolon: TokenSyntax {
    let child = data.cachedChild(at: Cursor.trailingSemicolon.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTrailingSemicolon(_ newChild: TokenSyntax) -> RightFixDeclSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.trailingSemicolon)
    return RightFixDeclSyntax(root: root, data: newData)
  }

}

public struct PatternClauseListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new PatternClauseListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> PatternClauseListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return PatternClauseListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new PatternClauseListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: ExprSyntax) -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: ExprSyntax) -> PatternClauseListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new PatternClauseListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new PatternClauseListSyntax with that element appended to the end.
  public func inserting(_ syntax: ExprSyntax,
                        at index: Int) -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new PatternClauseListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by removing the first element.
  ///
  /// - Returns: A new PatternClauseListSyntax with the first element removed.
  public func removingFirst() -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new PatternClauseListSyntax by removing the last element.
  ///
  /// - Returns: A new PatternClauseListSyntax with the last element removed.
  public func removingLast() -> PatternClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> PatternClauseListSyntaxIterator {
    return PatternClauseListSyntaxIterator(collection: self)
  }
}

/// Conformance for PatternClauseListSyntax to the Collection protocol.
extension PatternClauseListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> ExprSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! ExprSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct PatternClauseListSyntaxIterator: IteratorProtocol {
  private let collection: PatternClauseListSyntax
  private var index: PatternClauseListSyntax.Index

  fileprivate init(collection: PatternClauseListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> ExprSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct LambdaExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case slashToken
    case bindingList
    case arrowToken
    case bodyExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var slashToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.slashToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withSlashToken(_ newChild: TokenSyntax) -> LambdaExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.slashToken)
    return LambdaExprSyntax(root: root, data: newData)
  }

  public var bindingList: BindingListSyntax {
    let child = data.cachedChild(at: Cursor.bindingList.rawValue)

    return makeSyntax(root: _root, data: child!) as! BindingListSyntax
  }
  public func withBindingList(_ newChild: BindingListSyntax) -> LambdaExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.bindingList)
    return LambdaExprSyntax(root: root, data: newData)
  }

  public var arrowToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.arrowToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withArrowToken(_ newChild: TokenSyntax) -> LambdaExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arrowToken)
    return LambdaExprSyntax(root: root, data: newData)
  }

  public var bodyExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.bodyExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withBodyExpr(_ newChild: ExprSyntax) -> LambdaExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.bodyExpr)
    return LambdaExprSyntax(root: root, data: newData)
  }

}

public struct QuantifiedExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case forallToken
    case bindingList
    case arrowToken
    case outputExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var forallToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.forallToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withForallToken(_ newChild: TokenSyntax) -> QuantifiedExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.forallToken)
    return QuantifiedExprSyntax(root: root, data: newData)
  }

  public var bindingList: TypedParameterListSyntax {
    let child = data.cachedChild(at: Cursor.bindingList.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypedParameterListSyntax
  }
  public func withBindingList(_ newChild: TypedParameterListSyntax) -> QuantifiedExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.bindingList)
    return QuantifiedExprSyntax(root: root, data: newData)
  }

  public var arrowToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.arrowToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withArrowToken(_ newChild: TokenSyntax) -> QuantifiedExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.arrowToken)
    return QuantifiedExprSyntax(root: root, data: newData)
  }

  public var outputExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.outputExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withOutputExpr(_ newChild: ExprSyntax) -> QuantifiedExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.outputExpr)
    return QuantifiedExprSyntax(root: root, data: newData)
  }

}

public struct LetExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case letToken
    case leftBraceToken
    case declList
    case rightBraceToken
    case inToken
    case outputExpr
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var letToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.letToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLetToken(_ newChild: TokenSyntax) -> LetExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.letToken)
    return LetExprSyntax(root: root, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftBraceToken(_ newChild: TokenSyntax) -> LetExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBraceToken)
    return LetExprSyntax(root: root, data: newData)
  }

  public var declList: DeclListSyntax {
    let child = data.cachedChild(at: Cursor.declList.rawValue)

    return makeSyntax(root: _root, data: child!) as! DeclListSyntax
  }
  public func withDeclList(_ newChild: DeclListSyntax) -> LetExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.declList)
    return LetExprSyntax(root: root, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightBraceToken(_ newChild: TokenSyntax) -> LetExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBraceToken)
    return LetExprSyntax(root: root, data: newData)
  }

  public var inToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.inToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withInToken(_ newChild: TokenSyntax) -> LetExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.inToken)
    return LetExprSyntax(root: root, data: newData)
  }

  public var outputExpr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.outputExpr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withOutputExpr(_ newChild: ExprSyntax) -> LetExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.outputExpr)
    return LetExprSyntax(root: root, data: newData)
  }

}

public struct ApplicationExprSyntax: ExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case exprs
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var exprs: BasicExprListSyntax {
    let child = data.cachedChild(at: Cursor.exprs.rawValue)

    return makeSyntax(root: _root, data: child!) as! BasicExprListSyntax
  }
  public func withExprs(_ newChild: BasicExprListSyntax) -> ApplicationExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.exprs)
    return ApplicationExprSyntax(root: root, data: newData)
  }

}

public struct BindingListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new BindingListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> BindingListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return BindingListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new BindingListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: BindingSyntax) -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: BindingSyntax) -> BindingListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new BindingListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new BindingListSyntax with that element appended to the end.
  public func inserting(_ syntax: BindingSyntax,
                        at index: Int) -> BindingListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new BindingListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by removing the first element.
  ///
  /// - Returns: A new BindingListSyntax with the first element removed.
  public func removingFirst() -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new BindingListSyntax by removing the last element.
  ///
  /// - Returns: A new BindingListSyntax with the last element removed.
  public func removingLast() -> BindingListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> BindingListSyntaxIterator {
    return BindingListSyntaxIterator(collection: self)
  }
}

/// Conformance for BindingListSyntax to the Collection protocol.
extension BindingListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> BindingSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! BindingSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct BindingListSyntaxIterator: IteratorProtocol {
  private let collection: BindingListSyntax
  private var index: BindingListSyntax.Index

  fileprivate init(collection: BindingListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> BindingSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct NamedBindingSyntax: BindingSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case name
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var name: QualifiedNameSyntax {
    let child = data.cachedChild(at: Cursor.name.rawValue)

    return makeSyntax(root: _root, data: child!) as! QualifiedNameSyntax
  }
  public func withName(_ newChild: QualifiedNameSyntax) -> NamedBindingSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return NamedBindingSyntax(root: root, data: newData)
  }

}

public struct TypedBindingSyntax: BindingSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case parameter
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var parameter: TypedParameterSyntax {
    let child = data.cachedChild(at: Cursor.parameter.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypedParameterSyntax
  }
  public func withParameter(_ newChild: TypedParameterSyntax) -> TypedBindingSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.parameter)
    return TypedBindingSyntax(root: root, data: newData)
  }

}

public struct AnonymousBindingSyntax: BindingSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case underscoreToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var underscoreToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.underscoreToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withUnderscoreToken(_ newChild: TokenSyntax) -> AnonymousBindingSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.underscoreToken)
    return AnonymousBindingSyntax(root: root, data: newData)
  }

}

public struct BasicExprListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new BasicExprListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> BasicExprListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return BasicExprListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new BasicExprListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: BasicExprSyntax) -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: BasicExprSyntax) -> BasicExprListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new BasicExprListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new BasicExprListSyntax with that element appended to the end.
  public func inserting(_ syntax: BasicExprSyntax,
                        at index: Int) -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new BasicExprListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by removing the first element.
  ///
  /// - Returns: A new BasicExprListSyntax with the first element removed.
  public func removingFirst() -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new BasicExprListSyntax by removing the last element.
  ///
  /// - Returns: A new BasicExprListSyntax with the last element removed.
  public func removingLast() -> BasicExprListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> BasicExprListSyntaxIterator {
    return BasicExprListSyntaxIterator(collection: self)
  }
}

/// Conformance for BasicExprListSyntax to the Collection protocol.
extension BasicExprListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> BasicExprSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! BasicExprSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct BasicExprListSyntaxIterator: IteratorProtocol {
  private let collection: BasicExprListSyntax
  private var index: BasicExprListSyntax.Index

  fileprivate init(collection: BasicExprListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> BasicExprSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct NamedBasicExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case name
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var name: QualifiedNameSyntax {
    let child = data.cachedChild(at: Cursor.name.rawValue)

    return makeSyntax(root: _root, data: child!) as! QualifiedNameSyntax
  }
  public func withName(_ newChild: QualifiedNameSyntax) -> NamedBasicExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.name)
    return NamedBasicExprSyntax(root: root, data: newData)
  }

}

public struct UnderscoreExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case underscoreToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var underscoreToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.underscoreToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withUnderscoreToken(_ newChild: TokenSyntax) -> UnderscoreExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.underscoreToken)
    return UnderscoreExprSyntax(root: root, data: newData)
  }

}

public struct AbsurdExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case leftParenToken
    case rightParenToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var leftParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftParenToken(_ newChild: TokenSyntax) -> AbsurdExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParenToken)
    return AbsurdExprSyntax(root: root, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightParenToken(_ newChild: TokenSyntax) -> AbsurdExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParenToken)
    return AbsurdExprSyntax(root: root, data: newData)
  }

}

public struct TypeBasicExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case typeToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var typeToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.typeToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withTypeToken(_ newChild: TokenSyntax) -> TypeBasicExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.typeToken)
    return TypeBasicExprSyntax(root: root, data: newData)
  }

}

public struct ParenthesizedExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case leftParenToken
    case expr
    case rightParenToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var leftParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftParenToken(_ newChild: TokenSyntax) -> ParenthesizedExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftParenToken)
    return ParenthesizedExprSyntax(root: root, data: newData)
  }

  public var expr: ExprSyntax {
    let child = data.cachedChild(at: Cursor.expr.rawValue)

    return makeSyntax(root: _root, data: child!) as! ExprSyntax
  }
  public func withExpr(_ newChild: ExprSyntax) -> ParenthesizedExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.expr)
    return ParenthesizedExprSyntax(root: root, data: newData)
  }

  public var rightParenToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightParenToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightParenToken(_ newChild: TokenSyntax) -> ParenthesizedExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightParenToken)
    return ParenthesizedExprSyntax(root: root, data: newData)
  }

}

public struct TypedParameterGroupExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case parameters
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var parameters: TypedParameterListSyntax {
    let child = data.cachedChild(at: Cursor.parameters.rawValue)

    return makeSyntax(root: _root, data: child!) as! TypedParameterListSyntax
  }
  public func withParameters(_ newChild: TypedParameterListSyntax) -> TypedParameterGroupExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.parameters)
    return TypedParameterGroupExprSyntax(root: root, data: newData)
  }

}

public struct RecordExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case recordToken
    case parameterExpr
    case leftBraceToken
    case fieldAssignments
    case rightBraceToken
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var recordToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.recordToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRecordToken(_ newChild: TokenSyntax) -> RecordExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.recordToken)
    return RecordExprSyntax(root: root, data: newData)
  }

  public var parameterExpr: BasicExprSyntax? {
    let child = data.cachedChild(at: Cursor.parameterExpr.rawValue)
    if child == nil { return nil }
    return makeSyntax(root: _root, data: child!) as? BasicExprSyntax
  }
  public func withParameterExpr(_ newChild: BasicExprSyntax?) -> RecordExprSyntax {
    let raw = newChild?.raw ?? RawSyntax.missing(.basicExpr)
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.parameterExpr)
    return RecordExprSyntax(root: root, data: newData)
  }

  public var leftBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.leftBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withLeftBraceToken(_ newChild: TokenSyntax) -> RecordExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.leftBraceToken)
    return RecordExprSyntax(root: root, data: newData)
  }

  public var fieldAssignments: RecordFieldAssignmentListSyntax {
    let child = data.cachedChild(at: Cursor.fieldAssignments.rawValue)

    return makeSyntax(root: _root, data: child!) as! RecordFieldAssignmentListSyntax
  }
  public func withFieldAssignments(_ newChild: RecordFieldAssignmentListSyntax) -> RecordExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.fieldAssignments)
    return RecordExprSyntax(root: root, data: newData)
  }

  public var rightBraceToken: TokenSyntax {
    let child = data.cachedChild(at: Cursor.rightBraceToken.rawValue)

    return makeSyntax(root: _root, data: child!) as! TokenSyntax
  }
  public func withRightBraceToken(_ newChild: TokenSyntax) -> RecordExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.rightBraceToken)
    return RecordExprSyntax(root: root, data: newData)
  }

}

public struct FunctionClauseListSyntax: _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }

  /// Creates a new FunctionClauseListSyntax by replacing the underlying layout with
  /// a different set of raw syntax nodes.
  ///
  /// - Parameter layout: The new list of raw syntax nodes underlying this
  ///                     collection.
  /// - Returns: A new SyntaxCollection with the new layout underlying it.
  internal func replacingLayout(
    _ layout: [RawSyntax?]) -> FunctionClauseListSyntax {
    let newRaw = data.raw.replacingLayout(layout)
    let (newRoot, newData) = data.replacingSelf(newRaw)
    return FunctionClauseListSyntax(root: newRoot, data: newData)
  }

  /// Creates a new FunctionClauseListSyntax by appending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to append.
  /// - Returns: A new SyntaxCollection with that element appended to the end.
  public func appending(
    _ syntax: FunctionClauseDeclSyntax) -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.append(syntax.raw)
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by prepending the provided syntax element
  /// to the children.
  ///
  /// - Parameter syntax: The element to prepend.
  /// - Returns: A new SyntaxCollection with that element prepended to the
  ///            beginning.
  public func prepending(
    _ syntax: FunctionClauseDeclSyntax) -> FunctionClauseListSyntax {
    return inserting(syntax, at: 0)
  }

  /// Creates a new FunctionClauseListSyntax by inserting the provided syntax element
  /// at the provided index in the children.
  ///
  /// - Parameters:
  ///   - syntax: The element to insert.
  ///   - index: The index at which to insert the element in the collection.
  ///
  /// - Returns: A new FunctionClauseListSyntax with that element appended to the end.
  public func inserting(_ syntax: FunctionClauseDeclSyntax,
                        at index: Int) -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    /// Make sure the index is a valid insertion index (0 to 1 past the end)
    precondition((newLayout.startIndex...newLayout.endIndex).contains(index),
                 "inserting node at invalid index \(index)")
    newLayout.insert(syntax.raw, at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by removing the syntax element at the
  /// provided index.
  ///
  /// - Parameter index: The index of the element to remove from the collection.
  /// - Returns: A new FunctionClauseListSyntax with the element at the provided index
  ///            removed.
  public func removing(childAt index: Int) -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.remove(at: index)
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by removing the first element.
  ///
  /// - Returns: A new FunctionClauseListSyntax with the first element removed.
  public func removingFirst() -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeFirst()
    return replacingLayout(newLayout)
  }

  /// Creates a new FunctionClauseListSyntax by removing the last element.
  ///
  /// - Returns: A new FunctionClauseListSyntax with the last element removed.
  public func removingLast() -> FunctionClauseListSyntax {
    var newLayout = data.raw.layout
    newLayout.removeLast()
    return replacingLayout(newLayout)
  }

  /// Returns an iterator over the elements of this syntax collection.
  public func makeIterator() -> FunctionClauseListSyntaxIterator {
    return FunctionClauseListSyntaxIterator(collection: self)
  }
}

/// Conformance for FunctionClauseListSyntax to the Collection protocol.
extension FunctionClauseListSyntax: Collection {
  public var startIndex: Int {
    return data.childCaches.startIndex
  }

  public var endIndex: Int {
    return data.childCaches.endIndex
  }

  public func index(after i: Int) -> Int {
    return data.childCaches.index(after: i)
  }

  public subscript(_ index: Int) -> FunctionClauseDeclSyntax {
    // swiftlint:disable force_cast
    return child(at: index)! as! FunctionClauseDeclSyntax
  }
}

/// A type that iterates over a syntax collection using its indices.
public struct FunctionClauseListSyntaxIterator: IteratorProtocol {
  private let collection: FunctionClauseListSyntax
  private var index: FunctionClauseListSyntax.Index

  fileprivate init(collection: FunctionClauseListSyntax) {
    self.collection = collection
    self.index = collection.startIndex
  }

  public mutating func next() -> FunctionClauseDeclSyntax? {
    guard
      !(self.collection.isEmpty || self.index == self.collection.endIndex)
    else {
      return nil
    }

    let result = collection[index]
    collection.formIndex(after: &index)
    return result
  }
}
public struct ReparsedApplicationExprSyntax: BasicExprSyntax, _SyntaxBase {
  let _root: SyntaxData
  unowned let _data: SyntaxData
  public enum Cursor: Int {
    case head
    case exprs
  }

  internal init(root: SyntaxData, data: SyntaxData) {
    self._root = root
    self._data = data
  }
  public var head: NamedBasicExprSyntax {
    let child = data.cachedChild(at: Cursor.head.rawValue)

    return makeSyntax(root: _root, data: child!) as! NamedBasicExprSyntax
  }
  public func withHead(_ newChild: NamedBasicExprSyntax) -> ReparsedApplicationExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.head)
    return ReparsedApplicationExprSyntax(root: root, data: newData)
  }

  public var exprs: BasicExprListSyntax {
    let child = data.cachedChild(at: Cursor.exprs.rawValue)

    return makeSyntax(root: _root, data: child!) as! BasicExprListSyntax
  }
  public func withExprs(_ newChild: BasicExprListSyntax) -> ReparsedApplicationExprSyntax {
    let raw = newChild.raw
    let (root, newData) = data.replacingChild(raw,
                                              at: Cursor.exprs)
    return ReparsedApplicationExprSyntax(root: root, data: newData)
  }

}

