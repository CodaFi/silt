/// SyntaxFactory.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017-2019, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
// swiftlint:disable line_length
// swiftlint:disable function_parameter_count
// swiftlint:disable type_body_length

public enum SyntaxFactory {
  public static func makeToken(_ kind: TokenKind, presence: SourcePresence,
                               leadingTrivia: Trivia = [],
                               trailingTrivia: Trivia = []) -> TokenSyntax {
    let raw = RawSyntax.createAndCalcLength(
      kind: kind,
      leadingTrivia: leadingTrivia,
      trailingTrivia: trailingTrivia, presence: presence)
    let data = SyntaxData(raw: raw)
    return TokenSyntax(root: data, data: data)
  }

  public static func makeUnknownSyntax(tokens: [TokenSyntax]) -> Syntax {
    let raw = RawSyntax.createAndCalcLength(kind: .unknown,
      layout: tokens.map { $0.data.raw }, presence: .present)
    let data = SyntaxData(raw: raw)
    return UnknownSyntax(root: data, data: data)
  }
  public static func makeSourceFileSyntax(
    _ elements: [TokenSyntax]) -> SourceFileSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.sourceFile,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return SourceFileSyntax(root: data, data: data)
  }
  public static func makeIdentifierListSyntax(
    _ elements: [TokenSyntax]) -> IdentifierListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.identifierList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return IdentifierListSyntax(root: data, data: data)
  }
  public static func makeQualifiedNameSyntax(
    _ elements: [QualifiedNamePieceSyntax]) -> QualifiedNameSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.qualifiedName,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return QualifiedNameSyntax(root: data, data: data)
  }
  public static func makeQualifiedNamePiece(
    name: TokenSyntax,
    trailingPeriod: TokenSyntax?
  ) -> QualifiedNamePieceSyntax {
    let layout: [RawSyntax?] = [
      name.data.raw,
      trailingPeriod?.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.qualifiedNamePiece,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return QualifiedNamePieceSyntax(root: data, data: data)
  }
  public static func makeBlankQualifiedNamePiece() -> QualifiedNamePieceSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .qualifiedNamePiece,
                                         layout: [
      RawSyntax.missingToken(.identifier("")),
      nil,
    ], length: .zero, presence: .present))
    return QualifiedNamePieceSyntax(root: data, data: data)
  }
  public static func makeModuleDecl(
    moduleToken: TokenSyntax,
    moduleIdentifier: QualifiedNameSyntax,
    typedParameterList: TypedParameterListSyntax,
    whereToken: TokenSyntax,
    leftBraceToken: TokenSyntax,
    declList: DeclListSyntax,
    rightBraceToken: TokenSyntax,
    trailingSemicolon: TokenSyntax
  ) -> ModuleDeclSyntax {
    let layout: [RawSyntax?] = [
      moduleToken.data.raw,
      moduleIdentifier.data.raw,
      typedParameterList.data.raw,
      whereToken.data.raw,
      leftBraceToken.data.raw,
      declList.data.raw,
      rightBraceToken.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.moduleDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ModuleDeclSyntax(root: data, data: data)
  }
  public static func makeBlankModuleDecl() -> ModuleDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .moduleDecl,
                                         layout: [
      RawSyntax.missingToken(.moduleKeyword),
      RawSyntax.missing(.qualifiedName),
      RawSyntax.missing(.typedParameterList),
      RawSyntax.missingToken(.whereKeyword),
      RawSyntax.missingToken(.leftBrace),
      RawSyntax.missing(.declList),
      RawSyntax.missingToken(.rightBrace),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return ModuleDeclSyntax(root: data, data: data)
  }
  public static func makeDeclListSyntax(
    _ elements: [DeclSyntax]) -> DeclListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.declList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return DeclListSyntax(root: data, data: data)
  }
  public static func makeOpenImportDecl(
    openToken: TokenSyntax?,
    importToken: TokenSyntax,
    importIdentifier: QualifiedNameSyntax,
    trailingSemicolon: TokenSyntax
  ) -> OpenImportDeclSyntax {
    let layout: [RawSyntax?] = [
      openToken?.data.raw,
      importToken.data.raw,
      importIdentifier.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.openImportDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return OpenImportDeclSyntax(root: data, data: data)
  }
  public static func makeBlankOpenImportDecl() -> OpenImportDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .openImportDecl,
                                         layout: [
      nil,
      RawSyntax.missingToken(.importKeyword),
      RawSyntax.missing(.qualifiedName),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return OpenImportDeclSyntax(root: data, data: data)
  }
  public static func makeImportDecl(
    importToken: TokenSyntax,
    importIdentifier: QualifiedNameSyntax,
    trailingSemicolon: TokenSyntax
  ) -> ImportDeclSyntax {
    let layout: [RawSyntax?] = [
      importToken.data.raw,
      importIdentifier.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.importDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ImportDeclSyntax(root: data, data: data)
  }
  public static func makeBlankImportDecl() -> ImportDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .importDecl,
                                         layout: [
      RawSyntax.missingToken(.importKeyword),
      RawSyntax.missing(.qualifiedName),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return ImportDeclSyntax(root: data, data: data)
  }
  public static func makeDataDecl(
    dataToken: TokenSyntax,
    dataIdentifier: TokenSyntax,
    typedParameterList: TypedParameterListSyntax,
    typeIndices: TypeIndicesSyntax,
    whereToken: TokenSyntax,
    leftBraceToken: TokenSyntax,
    constructorList: ConstructorListSyntax,
    rightBraceToken: TokenSyntax,
    trailingSemicolon: TokenSyntax
  ) -> DataDeclSyntax {
    let layout: [RawSyntax?] = [
      dataToken.data.raw,
      dataIdentifier.data.raw,
      typedParameterList.data.raw,
      typeIndices.data.raw,
      whereToken.data.raw,
      leftBraceToken.data.raw,
      constructorList.data.raw,
      rightBraceToken.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.dataDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return DataDeclSyntax(root: data, data: data)
  }
  public static func makeBlankDataDecl() -> DataDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .dataDecl,
                                         layout: [
      RawSyntax.missingToken(.dataKeyword),
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missing(.typedParameterList),
      RawSyntax.missing(.typeIndices),
      RawSyntax.missingToken(.whereKeyword),
      RawSyntax.missingToken(.leftBrace),
      RawSyntax.missing(.constructorList),
      RawSyntax.missingToken(.rightBrace),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return DataDeclSyntax(root: data, data: data)
  }
  public static func makeEmptyDataDecl(
    dataToken: TokenSyntax,
    dataIdentifier: TokenSyntax,
    typedParameterList: TypedParameterListSyntax,
    typeIndices: TypeIndicesSyntax,
    trailingSemicolon: TokenSyntax
  ) -> EmptyDataDeclSyntax {
    let layout: [RawSyntax?] = [
      dataToken.data.raw,
      dataIdentifier.data.raw,
      typedParameterList.data.raw,
      typeIndices.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.emptyDataDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return EmptyDataDeclSyntax(root: data, data: data)
  }
  public static func makeBlankEmptyDataDecl() -> EmptyDataDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .emptyDataDecl,
                                         layout: [
      RawSyntax.missingToken(.dataKeyword),
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missing(.typedParameterList),
      RawSyntax.missing(.typeIndices),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return EmptyDataDeclSyntax(root: data, data: data)
  }
  public static func makeTypeIndices(
    colonToken: TokenSyntax,
    indexExpr: ExprSyntax
  ) -> TypeIndicesSyntax {
    let layout: [RawSyntax?] = [
      colonToken.data.raw,
      indexExpr.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.typeIndices,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return TypeIndicesSyntax(root: data, data: data)
  }
  public static func makeBlankTypeIndices() -> TypeIndicesSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .typeIndices,
                                         layout: [
      RawSyntax.missingToken(.colon),
      RawSyntax.missing(.expr),
    ], length: .zero, presence: .present))
    return TypeIndicesSyntax(root: data, data: data)
  }
  public static func makeTypedParameterListSyntax(
    _ elements: [TypedParameterSyntax]) -> TypedParameterListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.typedParameterList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return TypedParameterListSyntax(root: data, data: data)
  }
  public static func makeAscription(
    boundNames: IdentifierListSyntax,
    colonToken: TokenSyntax,
    typeExpr: ExprSyntax
  ) -> AscriptionSyntax {
    let layout: [RawSyntax?] = [
      boundNames.data.raw,
      colonToken.data.raw,
      typeExpr.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.ascription,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return AscriptionSyntax(root: data, data: data)
  }
  public static func makeBlankAscription() -> AscriptionSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .ascription,
                                         layout: [
      RawSyntax.missing(.identifierList),
      RawSyntax.missingToken(.colon),
      RawSyntax.missing(.expr),
    ], length: .zero, presence: .present))
    return AscriptionSyntax(root: data, data: data)
  }
  public static func makeExplicitTypedParameter(
    leftParenToken: TokenSyntax,
    ascription: AscriptionSyntax,
    rightParenToken: TokenSyntax
  ) -> ExplicitTypedParameterSyntax {
    let layout: [RawSyntax?] = [
      leftParenToken.data.raw,
      ascription.data.raw,
      rightParenToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.explicitTypedParameter,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ExplicitTypedParameterSyntax(root: data, data: data)
  }
  public static func makeBlankExplicitTypedParameter() -> ExplicitTypedParameterSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .explicitTypedParameter,
                                         layout: [
      RawSyntax.missingToken(.leftParen),
      RawSyntax.missing(.ascription),
      RawSyntax.missingToken(.rightParen),
    ], length: .zero, presence: .present))
    return ExplicitTypedParameterSyntax(root: data, data: data)
  }
  public static func makeImplicitTypedParameter(
    leftBraceToken: TokenSyntax,
    ascription: AscriptionSyntax,
    rightBraceToken: TokenSyntax
  ) -> ImplicitTypedParameterSyntax {
    let layout: [RawSyntax?] = [
      leftBraceToken.data.raw,
      ascription.data.raw,
      rightBraceToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.implicitTypedParameter,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ImplicitTypedParameterSyntax(root: data, data: data)
  }
  public static func makeBlankImplicitTypedParameter() -> ImplicitTypedParameterSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .implicitTypedParameter,
                                         layout: [
      RawSyntax.missingToken(.leftBrace),
      RawSyntax.missing(.ascription),
      RawSyntax.missingToken(.rightBrace),
    ], length: .zero, presence: .present))
    return ImplicitTypedParameterSyntax(root: data, data: data)
  }
  public static func makeConstructorListSyntax(
    _ elements: [ConstructorDeclSyntax]) -> ConstructorListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.constructorList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ConstructorListSyntax(root: data, data: data)
  }
  public static func makeConstructorDecl(
    ascription: AscriptionSyntax,
    trailingSemicolon: TokenSyntax
  ) -> ConstructorDeclSyntax {
    let layout: [RawSyntax?] = [
      ascription.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.constructorDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ConstructorDeclSyntax(root: data, data: data)
  }
  public static func makeBlankConstructorDecl() -> ConstructorDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .constructorDecl,
                                         layout: [
      RawSyntax.missing(.ascription),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return ConstructorDeclSyntax(root: data, data: data)
  }
  public static func makeRecordDecl(
    recordToken: TokenSyntax,
    recordName: TokenSyntax,
    parameterList: TypedParameterListSyntax,
    typeIndices: TypeIndicesSyntax,
    whereToken: TokenSyntax,
    leftParenToken: TokenSyntax,
    recordElementList: DeclListSyntax,
    rightParenToken: TokenSyntax,
    trailingSemicolon: TokenSyntax
  ) -> RecordDeclSyntax {
    let layout: [RawSyntax?] = [
      recordToken.data.raw,
      recordName.data.raw,
      parameterList.data.raw,
      typeIndices.data.raw,
      whereToken.data.raw,
      leftParenToken.data.raw,
      recordElementList.data.raw,
      rightParenToken.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.recordDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return RecordDeclSyntax(root: data, data: data)
  }
  public static func makeBlankRecordDecl() -> RecordDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .recordDecl,
                                         layout: [
      RawSyntax.missingToken(.recordKeyword),
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missing(.typedParameterList),
      RawSyntax.missing(.typeIndices),
      RawSyntax.missingToken(.whereKeyword),
      RawSyntax.missingToken(.leftParen),
      RawSyntax.missing(.declList),
      RawSyntax.missingToken(.rightParen),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return RecordDeclSyntax(root: data, data: data)
  }
  public static func makeFieldDecl(
    fieldToken: TokenSyntax,
    ascription: AscriptionSyntax,
    trailingSemicolon: TokenSyntax
  ) -> FieldDeclSyntax {
    let layout: [RawSyntax?] = [
      fieldToken.data.raw,
      ascription.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.fieldDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return FieldDeclSyntax(root: data, data: data)
  }
  public static func makeBlankFieldDecl() -> FieldDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .fieldDecl,
                                         layout: [
      RawSyntax.missingToken(.fieldKeyword),
      RawSyntax.missing(.ascription),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return FieldDeclSyntax(root: data, data: data)
  }
  public static func makeRecordConstructorDecl(
    constructorToken: TokenSyntax,
    constructorName: TokenSyntax,
    trailingSemicolon: TokenSyntax
  ) -> RecordConstructorDeclSyntax {
    let layout: [RawSyntax?] = [
      constructorToken.data.raw,
      constructorName.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.recordConstructorDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return RecordConstructorDeclSyntax(root: data, data: data)
  }
  public static func makeBlankRecordConstructorDecl() -> RecordConstructorDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .recordConstructorDecl,
                                         layout: [
      RawSyntax.missingToken(.constructorKeyword),
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return RecordConstructorDeclSyntax(root: data, data: data)
  }
  public static func makeRecordFieldAssignmentListSyntax(
    _ elements: [RecordFieldAssignmentSyntax]) -> RecordFieldAssignmentListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.recordFieldAssignmentList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return RecordFieldAssignmentListSyntax(root: data, data: data)
  }
  public static func makeRecordFieldAssignment(
    fieldName: TokenSyntax,
    equalsToken: TokenSyntax,
    fieldInitExpr: ExprSyntax,
    trailingSemicolon: TokenSyntax?
  ) -> RecordFieldAssignmentSyntax {
    let layout: [RawSyntax?] = [
      fieldName.data.raw,
      equalsToken.data.raw,
      fieldInitExpr.data.raw,
      trailingSemicolon?.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.recordFieldAssignment,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return RecordFieldAssignmentSyntax(root: data, data: data)
  }
  public static func makeBlankRecordFieldAssignment() -> RecordFieldAssignmentSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .recordFieldAssignment,
                                         layout: [
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missingToken(.equals),
      RawSyntax.missing(.expr),
      nil,
    ], length: .zero, presence: .present))
    return RecordFieldAssignmentSyntax(root: data, data: data)
  }
  public static func makeFunctionDecl(
    ascription: AscriptionSyntax,
    trailingSemicolon: TokenSyntax
  ) -> FunctionDeclSyntax {
    let layout: [RawSyntax?] = [
      ascription.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.functionDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return FunctionDeclSyntax(root: data, data: data)
  }
  public static func makeBlankFunctionDecl() -> FunctionDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .functionDecl,
                                         layout: [
      RawSyntax.missing(.ascription),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return FunctionDeclSyntax(root: data, data: data)
  }
  public static func makeWithRuleFunctionClauseDecl(
    basicExprList: BasicExprListSyntax,
    withToken: TokenSyntax,
    withExpr: ExprSyntax,
    withPatternClause: BasicExprListSyntax?,
    equalsToken: TokenSyntax,
    rhsExpr: ExprSyntax,
    whereClause: FunctionWhereClauseDeclSyntax?,
    trailingSemicolon: TokenSyntax
  ) -> WithRuleFunctionClauseDeclSyntax {
    let layout: [RawSyntax?] = [
      basicExprList.data.raw,
      withToken.data.raw,
      withExpr.data.raw,
      withPatternClause?.data.raw,
      equalsToken.data.raw,
      rhsExpr.data.raw,
      whereClause?.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.withRuleFunctionClauseDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return WithRuleFunctionClauseDeclSyntax(root: data, data: data)
  }
  public static func makeBlankWithRuleFunctionClauseDecl() -> WithRuleFunctionClauseDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .withRuleFunctionClauseDecl,
                                         layout: [
      RawSyntax.missing(.basicExprList),
      RawSyntax.missingToken(.withKeyword),
      RawSyntax.missing(.expr),
      nil,
      RawSyntax.missingToken(.equals),
      RawSyntax.missing(.expr),
      nil,
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return WithRuleFunctionClauseDeclSyntax(root: data, data: data)
  }
  public static func makeNormalFunctionClauseDecl(
    basicExprList: BasicExprListSyntax,
    equalsToken: TokenSyntax,
    rhsExpr: ExprSyntax,
    whereClause: FunctionWhereClauseDeclSyntax?,
    trailingSemicolon: TokenSyntax
  ) -> NormalFunctionClauseDeclSyntax {
    let layout: [RawSyntax?] = [
      basicExprList.data.raw,
      equalsToken.data.raw,
      rhsExpr.data.raw,
      whereClause?.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.normalFunctionClauseDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return NormalFunctionClauseDeclSyntax(root: data, data: data)
  }
  public static func makeBlankNormalFunctionClauseDecl() -> NormalFunctionClauseDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .normalFunctionClauseDecl,
                                         layout: [
      RawSyntax.missing(.basicExprList),
      RawSyntax.missingToken(.equals),
      RawSyntax.missing(.expr),
      nil,
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return NormalFunctionClauseDeclSyntax(root: data, data: data)
  }
  public static func makeAbsurdFunctionClauseDecl(
    basicExprList: BasicExprListSyntax,
    trailingSemicolon: TokenSyntax
  ) -> AbsurdFunctionClauseDeclSyntax {
    let layout: [RawSyntax?] = [
      basicExprList.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.absurdFunctionClauseDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return AbsurdFunctionClauseDeclSyntax(root: data, data: data)
  }
  public static func makeBlankAbsurdFunctionClauseDecl() -> AbsurdFunctionClauseDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .absurdFunctionClauseDecl,
                                         layout: [
      RawSyntax.missing(.basicExprList),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return AbsurdFunctionClauseDeclSyntax(root: data, data: data)
  }
  public static func makeFunctionWhereClauseDecl(
    whereToken: TokenSyntax,
    leftBraceToken: TokenSyntax,
    declList: DeclListSyntax,
    rightBraceToken: TokenSyntax
  ) -> FunctionWhereClauseDeclSyntax {
    let layout: [RawSyntax?] = [
      whereToken.data.raw,
      leftBraceToken.data.raw,
      declList.data.raw,
      rightBraceToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.functionWhereClauseDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return FunctionWhereClauseDeclSyntax(root: data, data: data)
  }
  public static func makeBlankFunctionWhereClauseDecl() -> FunctionWhereClauseDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .functionWhereClauseDecl,
                                         layout: [
      RawSyntax.missingToken(.whereKeyword),
      RawSyntax.missingToken(.leftBrace),
      RawSyntax.missing(.declList),
      RawSyntax.missingToken(.rightBrace),
    ], length: .zero, presence: .present))
    return FunctionWhereClauseDeclSyntax(root: data, data: data)
  }
  public static func makeLetBindingDecl(
    head: NamedBasicExprSyntax,
    basicExprList: BasicExprListSyntax,
    equalsToken: TokenSyntax,
    boundExpr: ExprSyntax,
    trailingSemicolon: TokenSyntax
  ) -> LetBindingDeclSyntax {
    let layout: [RawSyntax?] = [
      head.data.raw,
      basicExprList.data.raw,
      equalsToken.data.raw,
      boundExpr.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.letBindingDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return LetBindingDeclSyntax(root: data, data: data)
  }
  public static func makeBlankLetBindingDecl() -> LetBindingDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .letBindingDecl,
                                         layout: [
      RawSyntax.missing(.namedBasicExpr),
      RawSyntax.missing(.basicExprList),
      RawSyntax.missingToken(.equals),
      RawSyntax.missing(.expr),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return LetBindingDeclSyntax(root: data, data: data)
  }
  public static func makeNonFixDecl(
    infixToken: TokenSyntax,
    precedence: TokenSyntax,
    names: IdentifierListSyntax,
    trailingSemicolon: TokenSyntax
  ) -> NonFixDeclSyntax {
    let layout: [RawSyntax?] = [
      infixToken.data.raw,
      precedence.data.raw,
      names.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.nonFixDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return NonFixDeclSyntax(root: data, data: data)
  }
  public static func makeBlankNonFixDecl() -> NonFixDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .nonFixDecl,
                                         layout: [
      RawSyntax.missingToken(.infixKeyword),
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missing(.identifierList),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return NonFixDeclSyntax(root: data, data: data)
  }
  public static func makeLeftFixDecl(
    infixlToken: TokenSyntax,
    precedence: TokenSyntax,
    names: IdentifierListSyntax,
    trailingSemicolon: TokenSyntax
  ) -> LeftFixDeclSyntax {
    let layout: [RawSyntax?] = [
      infixlToken.data.raw,
      precedence.data.raw,
      names.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.leftFixDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return LeftFixDeclSyntax(root: data, data: data)
  }
  public static func makeBlankLeftFixDecl() -> LeftFixDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .leftFixDecl,
                                         layout: [
      RawSyntax.missingToken(.infixlKeyword),
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missing(.identifierList),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return LeftFixDeclSyntax(root: data, data: data)
  }
  public static func makeRightFixDecl(
    infixrToken: TokenSyntax,
    precedence: TokenSyntax,
    names: IdentifierListSyntax,
    trailingSemicolon: TokenSyntax
  ) -> RightFixDeclSyntax {
    let layout: [RawSyntax?] = [
      infixrToken.data.raw,
      precedence.data.raw,
      names.data.raw,
      trailingSemicolon.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.rightFixDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return RightFixDeclSyntax(root: data, data: data)
  }
  public static func makeBlankRightFixDecl() -> RightFixDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .rightFixDecl,
                                         layout: [
      RawSyntax.missingToken(.infixrKeyword),
      RawSyntax.missingToken(.identifier("")),
      RawSyntax.missing(.identifierList),
      RawSyntax.missingToken(.semicolon),
    ], length: .zero, presence: .present))
    return RightFixDeclSyntax(root: data, data: data)
  }
  public static func makePatternClauseListSyntax(
    _ elements: [ExprSyntax]) -> PatternClauseListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.patternClauseList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return PatternClauseListSyntax(root: data, data: data)
  }
  public static func makeLambdaExpr(
    slashToken: TokenSyntax,
    bindingList: BindingListSyntax,
    arrowToken: TokenSyntax,
    bodyExpr: ExprSyntax
  ) -> LambdaExprSyntax {
    let layout: [RawSyntax?] = [
      slashToken.data.raw,
      bindingList.data.raw,
      arrowToken.data.raw,
      bodyExpr.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.lambdaExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return LambdaExprSyntax(root: data, data: data)
  }
  public static func makeBlankLambdaExpr() -> LambdaExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .lambdaExpr,
                                         layout: [
      RawSyntax.missingToken(.unknown("")),
      RawSyntax.missing(.bindingList),
      RawSyntax.missingToken(.unknown("")),
      RawSyntax.missing(.expr),
    ], length: .zero, presence: .present))
    return LambdaExprSyntax(root: data, data: data)
  }
  public static func makeQuantifiedExpr(
    forallToken: TokenSyntax,
    bindingList: TypedParameterListSyntax,
    arrowToken: TokenSyntax,
    outputExpr: ExprSyntax
  ) -> QuantifiedExprSyntax {
    let layout: [RawSyntax?] = [
      forallToken.data.raw,
      bindingList.data.raw,
      arrowToken.data.raw,
      outputExpr.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.quantifiedExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return QuantifiedExprSyntax(root: data, data: data)
  }
  public static func makeBlankQuantifiedExpr() -> QuantifiedExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .quantifiedExpr,
                                         layout: [
      RawSyntax.missingToken(.forallKeyword),
      RawSyntax.missing(.typedParameterList),
      RawSyntax.missingToken(.unknown("")),
      RawSyntax.missing(.expr),
    ], length: .zero, presence: .present))
    return QuantifiedExprSyntax(root: data, data: data)
  }
  public static func makeLetExpr(
    letToken: TokenSyntax,
    leftBraceToken: TokenSyntax,
    declList: DeclListSyntax,
    rightBraceToken: TokenSyntax,
    inToken: TokenSyntax,
    outputExpr: ExprSyntax
  ) -> LetExprSyntax {
    let layout: [RawSyntax?] = [
      letToken.data.raw,
      leftBraceToken.data.raw,
      declList.data.raw,
      rightBraceToken.data.raw,
      inToken.data.raw,
      outputExpr.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.letExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return LetExprSyntax(root: data, data: data)
  }
  public static func makeBlankLetExpr() -> LetExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .letExpr,
                                         layout: [
      RawSyntax.missingToken(.letKeyword),
      RawSyntax.missingToken(.leftBrace),
      RawSyntax.missing(.declList),
      RawSyntax.missingToken(.rightBrace),
      RawSyntax.missingToken(.inKeyword),
      RawSyntax.missing(.expr),
    ], length: .zero, presence: .present))
    return LetExprSyntax(root: data, data: data)
  }
  public static func makeApplicationExpr(
    exprs: BasicExprListSyntax
  ) -> ApplicationExprSyntax {
    let layout: [RawSyntax?] = [
      exprs.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.applicationExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ApplicationExprSyntax(root: data, data: data)
  }
  public static func makeBlankApplicationExpr() -> ApplicationExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .applicationExpr,
                                         layout: [
      RawSyntax.missing(.basicExprList),
    ], length: .zero, presence: .present))
    return ApplicationExprSyntax(root: data, data: data)
  }
  public static func makeBindingListSyntax(
    _ elements: [BindingSyntax]) -> BindingListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.bindingList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return BindingListSyntax(root: data, data: data)
  }
  public static func makeNamedBinding(
    name: QualifiedNameSyntax
  ) -> NamedBindingSyntax {
    let layout: [RawSyntax?] = [
      name.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.namedBinding,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return NamedBindingSyntax(root: data, data: data)
  }
  public static func makeBlankNamedBinding() -> NamedBindingSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .namedBinding,
                                         layout: [
      RawSyntax.missing(.qualifiedName),
    ], length: .zero, presence: .present))
    return NamedBindingSyntax(root: data, data: data)
  }
  public static func makeTypedBinding(
    parameter: TypedParameterSyntax
  ) -> TypedBindingSyntax {
    let layout: [RawSyntax?] = [
      parameter.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.typedBinding,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return TypedBindingSyntax(root: data, data: data)
  }
  public static func makeBlankTypedBinding() -> TypedBindingSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .typedBinding,
                                         layout: [
      RawSyntax.missing(.typedParameter),
    ], length: .zero, presence: .present))
    return TypedBindingSyntax(root: data, data: data)
  }
  public static func makeAnonymousBinding(
    underscoreToken: TokenSyntax
  ) -> AnonymousBindingSyntax {
    let layout: [RawSyntax?] = [
      underscoreToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.anonymousBinding,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return AnonymousBindingSyntax(root: data, data: data)
  }
  public static func makeBlankAnonymousBinding() -> AnonymousBindingSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .anonymousBinding,
                                         layout: [
      RawSyntax.missingToken(.underscore),
    ], length: .zero, presence: .present))
    return AnonymousBindingSyntax(root: data, data: data)
  }
  public static func makeBasicExprListSyntax(
    _ elements: [BasicExprSyntax]) -> BasicExprListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.basicExprList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return BasicExprListSyntax(root: data, data: data)
  }
  public static func makeNamedBasicExpr(
    name: QualifiedNameSyntax
  ) -> NamedBasicExprSyntax {
    let layout: [RawSyntax?] = [
      name.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.namedBasicExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return NamedBasicExprSyntax(root: data, data: data)
  }
  public static func makeBlankNamedBasicExpr() -> NamedBasicExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .namedBasicExpr,
                                         layout: [
      RawSyntax.missing(.qualifiedName),
    ], length: .zero, presence: .present))
    return NamedBasicExprSyntax(root: data, data: data)
  }
  public static func makeUnderscoreExpr(
    underscoreToken: TokenSyntax
  ) -> UnderscoreExprSyntax {
    let layout: [RawSyntax?] = [
      underscoreToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.underscoreExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return UnderscoreExprSyntax(root: data, data: data)
  }
  public static func makeBlankUnderscoreExpr() -> UnderscoreExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .underscoreExpr,
                                         layout: [
      RawSyntax.missingToken(.underscore),
    ], length: .zero, presence: .present))
    return UnderscoreExprSyntax(root: data, data: data)
  }
  public static func makeAbsurdExpr(
    leftParenToken: TokenSyntax,
    rightParenToken: TokenSyntax
  ) -> AbsurdExprSyntax {
    let layout: [RawSyntax?] = [
      leftParenToken.data.raw,
      rightParenToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.absurdExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return AbsurdExprSyntax(root: data, data: data)
  }
  public static func makeBlankAbsurdExpr() -> AbsurdExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .absurdExpr,
                                         layout: [
      RawSyntax.missingToken(.leftParen),
      RawSyntax.missingToken(.rightParen),
    ], length: .zero, presence: .present))
    return AbsurdExprSyntax(root: data, data: data)
  }
  public static func makeTypeBasicExpr(
    typeToken: TokenSyntax
  ) -> TypeBasicExprSyntax {
    let layout: [RawSyntax?] = [
      typeToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.typeBasicExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return TypeBasicExprSyntax(root: data, data: data)
  }
  public static func makeBlankTypeBasicExpr() -> TypeBasicExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .typeBasicExpr,
                                         layout: [
      RawSyntax.missingToken(.typeKeyword),
    ], length: .zero, presence: .present))
    return TypeBasicExprSyntax(root: data, data: data)
  }
  public static func makeParenthesizedExpr(
    leftParenToken: TokenSyntax,
    expr: ExprSyntax,
    rightParenToken: TokenSyntax
  ) -> ParenthesizedExprSyntax {
    let layout: [RawSyntax?] = [
      leftParenToken.data.raw,
      expr.data.raw,
      rightParenToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.parenthesizedExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ParenthesizedExprSyntax(root: data, data: data)
  }
  public static func makeBlankParenthesizedExpr() -> ParenthesizedExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .parenthesizedExpr,
                                         layout: [
      RawSyntax.missingToken(.leftParen),
      RawSyntax.missing(.expr),
      RawSyntax.missingToken(.rightParen),
    ], length: .zero, presence: .present))
    return ParenthesizedExprSyntax(root: data, data: data)
  }
  public static func makeTypedParameterGroupExpr(
    parameters: TypedParameterListSyntax
  ) -> TypedParameterGroupExprSyntax {
    let layout: [RawSyntax?] = [
      parameters.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.typedParameterGroupExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return TypedParameterGroupExprSyntax(root: data, data: data)
  }
  public static func makeBlankTypedParameterGroupExpr() -> TypedParameterGroupExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .typedParameterGroupExpr,
                                         layout: [
      RawSyntax.missing(.typedParameterList),
    ], length: .zero, presence: .present))
    return TypedParameterGroupExprSyntax(root: data, data: data)
  }
  public static func makeRecordExpr(
    recordToken: TokenSyntax,
    parameterExpr: BasicExprSyntax?,
    leftBraceToken: TokenSyntax,
    fieldAssignments: RecordFieldAssignmentListSyntax,
    rightBraceToken: TokenSyntax
  ) -> RecordExprSyntax {
    let layout: [RawSyntax?] = [
      recordToken.data.raw,
      parameterExpr?.data.raw,
      leftBraceToken.data.raw,
      fieldAssignments.data.raw,
      rightBraceToken.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.recordExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return RecordExprSyntax(root: data, data: data)
  }
  public static func makeBlankRecordExpr() -> RecordExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .recordExpr,
                                         layout: [
      RawSyntax.missingToken(.unknown("")),
      nil,
      RawSyntax.missingToken(.leftBrace),
      RawSyntax.missing(.recordFieldAssignmentList),
      RawSyntax.missingToken(.rightBrace),
    ], length: .zero, presence: .present))
    return RecordExprSyntax(root: data, data: data)
  }
  public static func makeFunctionClauseListSyntax(
    _ elements: [FunctionClauseDeclSyntax]) -> FunctionClauseListSyntax {
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.functionClauseList,
      layout: elements.map { $0.data.raw }, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return FunctionClauseListSyntax(root: data, data: data)
  }
  public static func makeReparsedFunctionDecl(
    ascription: AscriptionSyntax,
    trailingSemicolon: TokenSyntax,
    clauseList: FunctionClauseListSyntax
  ) -> ReparsedFunctionDeclSyntax {
    let layout: [RawSyntax?] = [
      ascription.data.raw,
      trailingSemicolon.data.raw,
      clauseList.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.reparsedFunctionDecl,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ReparsedFunctionDeclSyntax(root: data, data: data)
  }
  public static func makeBlankReparsedFunctionDecl() -> ReparsedFunctionDeclSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .reparsedFunctionDecl,
                                         layout: [
      RawSyntax.missing(.ascription),
      RawSyntax.missingToken(.semicolon),
      RawSyntax.missing(.functionClauseList),
    ], length: .zero, presence: .present))
    return ReparsedFunctionDeclSyntax(root: data, data: data)
  }
  public static func makeReparsedApplicationExpr(
    head: NamedBasicExprSyntax,
    exprs: BasicExprListSyntax
  ) -> ReparsedApplicationExprSyntax {
    let layout: [RawSyntax?] = [
      head.data.raw,
      exprs.data.raw,
    ]
    let raw = RawSyntax.createAndCalcLength(kind: SyntaxKind.reparsedApplicationExpr,
      layout: layout, presence: SourcePresence.present)
    let data = SyntaxData(raw: raw)
    return ReparsedApplicationExprSyntax(root: data, data: data)
  }
  public static func makeBlankReparsedApplicationExpr() -> ReparsedApplicationExprSyntax {
    let data = SyntaxData(raw: RawSyntax(kind: .reparsedApplicationExpr,
                                         layout: [
      RawSyntax.missing(.namedBasicExpr),
      RawSyntax.missing(.basicExprList),
    ], length: .zero, presence: .present))
    return ReparsedApplicationExprSyntax(root: data, data: data)
  }
  public static func makeEquals(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.equals, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeLeftParen(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.leftParen, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeRightParen(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.rightParen, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeBackSlash(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.backSlash, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeLeftBrace(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.leftBrace, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeRightBrace(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.rightBrace, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeSemicolon(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.semicolon, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeColon(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.colon, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makePeriod(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.period, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makePipe(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.pipe, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeUnderscore(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.underscore, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeForallSymbol(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.forallSymbol, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeArrowSymbol(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.arrowSymbol, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeConstructorKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.constructorKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeModuleKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.moduleKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeOpenKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.openKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeImportKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.importKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeWhereKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.whereKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeWithKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.withKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeLetKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.letKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeInKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.inKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeTypeKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.typeKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeDataKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.dataKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeRecordKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.recordKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeFieldKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.fieldKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeForallKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.forallKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeInfixlKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.infixlKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeInfixrKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.infixrKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeInfixKeyword(
    leadingTrivia: Trivia = [],
    trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.infixKeyword, presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeIdentifier(
    _ text: String,
    leadingTrivia: Trivia = [], trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.identifier(text), presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
  public static func makeUnknown(
    _ text: String,
    leadingTrivia: Trivia = [], trailingTrivia: Trivia = [],
    presence: SourcePresence = .present) -> TokenSyntax {
    return makeToken(.unknown(text), presence: presence,
                     leadingTrivia: leadingTrivia,
                     trailingTrivia: trailingTrivia)
  }
}
