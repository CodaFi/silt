/// TokenKind.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017-2019, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
public enum TokenKind: Equatable {
  case eof
  case equals
  case leftParen
  case rightParen
  case backSlash
  case leftBrace
  case rightBrace
  case semicolon
  case colon
  case period
  case pipe
  case underscore
  case forallSymbol
  case arrowSymbol
  case constructorKeyword
  case moduleKeyword
  case openKeyword
  case importKeyword
  case whereKeyword
  case withKeyword
  case letKeyword
  case inKeyword
  case typeKeyword
  case dataKeyword
  case recordKeyword
  case fieldKeyword
  case forallKeyword
  case infixlKeyword
  case infixrKeyword
  case infixKeyword
  case identifier(String)
  case unknown(String)

  public init(text: String) {
    switch text {
    case "=": self = .equals
    case "(": self = .leftParen
    case ")": self = .rightParen
    case "\\": self = .backSlash
    case "{": self = .leftBrace
    case "}": self = .rightBrace
    case ";": self = .semicolon
    case ":": self = .colon
    case ".": self = .period
    case "|": self = .pipe
    case "_": self = .underscore
    case "∀": self = .forallSymbol
    case "→": self = .arrowSymbol
    case "constructor": self = .constructorKeyword
    case "module": self = .moduleKeyword
    case "open": self = .openKeyword
    case "import": self = .importKeyword
    case "where": self = .whereKeyword
    case "with": self = .withKeyword
    case "let": self = .letKeyword
    case "in": self = .inKeyword
    case "Type": self = .typeKeyword
    case "data": self = .dataKeyword
    case "record": self = .recordKeyword
    case "field": self = .fieldKeyword
    case "forall": self = .forallKeyword
    case "infixl": self = .infixlKeyword
    case "infixr": self = .infixrKeyword
    case "infix": self = .infixKeyword
    default: self = .identifier(text)
    }
  }
  public var text: String {
    switch self {
    case .eof: return ""
    case .equals: return "="
    case .leftParen: return "("
    case .rightParen: return ")"
    case .backSlash: return "\\"
    case .leftBrace: return "{"
    case .rightBrace: return "}"
    case .semicolon: return ";"
    case .colon: return ":"
    case .period: return "."
    case .pipe: return "|"
    case .underscore: return "_"
    case .forallSymbol: return "∀"
    case .arrowSymbol: return "→"
    case .constructorKeyword: return "constructor"
    case .moduleKeyword: return "module"
    case .openKeyword: return "open"
    case .importKeyword: return "import"
    case .whereKeyword: return "where"
    case .withKeyword: return "with"
    case .letKeyword: return "let"
    case .inKeyword: return "in"
    case .typeKeyword: return "Type"
    case .dataKeyword: return "data"
    case .recordKeyword: return "record"
    case .fieldKeyword: return "field"
    case .forallKeyword: return "forall"
    case .infixlKeyword: return "infixl"
    case .infixrKeyword: return "infixr"
    case .infixKeyword: return "infix"
    case .identifier(let text): return text.description
    case .unknown(let text): return text.description
    }
  }
  var sourceLength: SourceLength {
    switch self {
    case .eof: return .zero
    case .equals: return SourceLength(utf8Length: 1)
    case .leftParen: return SourceLength(utf8Length: 1)
    case .rightParen: return SourceLength(utf8Length: 1)
    case .backSlash: return SourceLength(utf8Length: 2)
    case .leftBrace: return SourceLength(utf8Length: 1)
    case .rightBrace: return SourceLength(utf8Length: 1)
    case .semicolon: return SourceLength(utf8Length: 1)
    case .colon: return SourceLength(utf8Length: 1)
    case .period: return SourceLength(utf8Length: 1)
    case .pipe: return SourceLength(utf8Length: 1)
    case .underscore: return SourceLength(utf8Length: 1)
    case .forallSymbol: return SourceLength(utf8Length: 3)
    case .arrowSymbol: return SourceLength(utf8Length: 3)
    case .constructorKeyword: return SourceLength(utf8Length: 11)
    case .moduleKeyword: return SourceLength(utf8Length: 6)
    case .openKeyword: return SourceLength(utf8Length: 4)
    case .importKeyword: return SourceLength(utf8Length: 6)
    case .whereKeyword: return SourceLength(utf8Length: 5)
    case .withKeyword: return SourceLength(utf8Length: 4)
    case .letKeyword: return SourceLength(utf8Length: 3)
    case .inKeyword: return SourceLength(utf8Length: 2)
    case .typeKeyword: return SourceLength(utf8Length: 4)
    case .dataKeyword: return SourceLength(utf8Length: 4)
    case .recordKeyword: return SourceLength(utf8Length: 6)
    case .fieldKeyword: return SourceLength(utf8Length: 5)
    case .forallKeyword: return SourceLength(utf8Length: 6)
    case .infixlKeyword: return SourceLength(utf8Length: 6)
    case .infixrKeyword: return SourceLength(utf8Length: 6)
    case .infixKeyword: return SourceLength(utf8Length: 5)
    case .identifier(let text): return SourceLength(of: text)
    case .unknown(let text): return SourceLength(of: text)
    }
  }
  public static func == (lhs: TokenKind, rhs: TokenKind) -> Bool {
    switch (lhs, rhs) {
    case (.eof, .eof): return true
    case (.equals, .equals): return true
    case (.leftParen, .leftParen): return true
    case (.rightParen, .rightParen): return true
    case (.backSlash, .backSlash): return true
    case (.leftBrace, .leftBrace): return true
    case (.rightBrace, .rightBrace): return true
    case (.semicolon, .semicolon): return true
    case (.colon, .colon): return true
    case (.period, .period): return true
    case (.pipe, .pipe): return true
    case (.underscore, .underscore): return true
    case (.forallSymbol, .forallSymbol): return true
    case (.arrowSymbol, .arrowSymbol): return true
    case (.constructorKeyword, .constructorKeyword): return true
    case (.moduleKeyword, .moduleKeyword): return true
    case (.openKeyword, .openKeyword): return true
    case (.importKeyword, .importKeyword): return true
    case (.whereKeyword, .whereKeyword): return true
    case (.withKeyword, .withKeyword): return true
    case (.letKeyword, .letKeyword): return true
    case (.inKeyword, .inKeyword): return true
    case (.typeKeyword, .typeKeyword): return true
    case (.dataKeyword, .dataKeyword): return true
    case (.recordKeyword, .recordKeyword): return true
    case (.fieldKeyword, .fieldKeyword): return true
    case (.forallKeyword, .forallKeyword): return true
    case (.infixlKeyword, .infixlKeyword): return true
    case (.infixrKeyword, .infixrKeyword): return true
    case (.infixKeyword, .infixKeyword): return true
    case (.identifier(let l),
          .identifier(let r)): return l == r
    case (.unknown(let l),
          .unknown(let r)): return l == r
    default: return false
    }
  }
}
