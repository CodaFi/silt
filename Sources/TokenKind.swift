/// TokenKind.swift
/// Automatically generated by SyntaxGen. Do not edit!
///
/// Copyright 2017-2019, The Silt Language Project.
///
/// This project is released under the MIT license, a copy of which is
/// available in the repository.
public enum TokenKind: Equatable {
  case eof
  case period
  case dataKeyword
  case colon
  case rightParen
  case equals
  case forallSymbol
  case whereKeyword
  case importKeyword
  case rightBrace
  case letKeyword
  case typeKeyword
  case backSlash
  case infixrKeyword
  case unknown(String)
  case forallKeyword
  case moduleKeyword
  case inKeyword
  case withKeyword
  case semicolon
  case arrowSymbol
  case pipe
  case leftParen
  case recordKeyword
  case leftBrace
  case constructorKeyword
  case fieldKeyword
  case identifier(String)
  case openKeyword
  case infixKeyword
  case underscore
  case infixlKeyword

  public init(text: String) {
    switch text {
    case ".": self = .period
    case "data": self = .dataKeyword
    case ":": self = .colon
    case ")": self = .rightParen
    case "=": self = .equals
    case "∀": self = .forallSymbol
    case "where": self = .whereKeyword
    case "import": self = .importKeyword
    case "}": self = .rightBrace
    case "let": self = .letKeyword
    case "Type": self = .typeKeyword
    case "\\": self = .backSlash
    case "infixr": self = .infixrKeyword
    case "forall": self = .forallKeyword
    case "module": self = .moduleKeyword
    case "in": self = .inKeyword
    case "with": self = .withKeyword
    case ";": self = .semicolon
    case "→": self = .arrowSymbol
    case "|": self = .pipe
    case "(": self = .leftParen
    case "record": self = .recordKeyword
    case "{": self = .leftBrace
    case "constructor": self = .constructorKeyword
    case "field": self = .fieldKeyword
    case "open": self = .openKeyword
    case "infix": self = .infixKeyword
    case "_": self = .underscore
    case "infixl": self = .infixlKeyword
    default: self = .identifier(text)
    }
  }
  public var text: String {
    switch self {
    case .eof: return ""
    case .period: return "."
    case .dataKeyword: return "data"
    case .colon: return ":"
    case .rightParen: return ")"
    case .equals: return "="
    case .forallSymbol: return "∀"
    case .whereKeyword: return "where"
    case .importKeyword: return "import"
    case .rightBrace: return "}"
    case .letKeyword: return "let"
    case .typeKeyword: return "Type"
    case .backSlash: return "\\"
    case .infixrKeyword: return "infixr"
    case .unknown(let text): return text.description
    case .forallKeyword: return "forall"
    case .moduleKeyword: return "module"
    case .inKeyword: return "in"
    case .withKeyword: return "with"
    case .semicolon: return ";"
    case .arrowSymbol: return "→"
    case .pipe: return "|"
    case .leftParen: return "("
    case .recordKeyword: return "record"
    case .leftBrace: return "{"
    case .constructorKeyword: return "constructor"
    case .fieldKeyword: return "field"
    case .identifier(let text): return text.description
    case .openKeyword: return "open"
    case .infixKeyword: return "infix"
    case .underscore: return "_"
    case .infixlKeyword: return "infixl"
    }
  }
  var sourceLength: SourceLength {
    switch self {
    case .eof: return .zero
    case .period: return SourceLength(utf8Length: 1)
    case .dataKeyword: return SourceLength(utf8Length: 4)
    case .colon: return SourceLength(utf8Length: 1)
    case .rightParen: return SourceLength(utf8Length: 1)
    case .equals: return SourceLength(utf8Length: 1)
    case .forallSymbol: return SourceLength(utf8Length: 3)
    case .whereKeyword: return SourceLength(utf8Length: 5)
    case .importKeyword: return SourceLength(utf8Length: 6)
    case .rightBrace: return SourceLength(utf8Length: 1)
    case .letKeyword: return SourceLength(utf8Length: 3)
    case .typeKeyword: return SourceLength(utf8Length: 4)
    case .backSlash: return SourceLength(utf8Length: 2)
    case .infixrKeyword: return SourceLength(utf8Length: 6)
    case .unknown(let text): return SourceLength(of: text)
    case .forallKeyword: return SourceLength(utf8Length: 6)
    case .moduleKeyword: return SourceLength(utf8Length: 6)
    case .inKeyword: return SourceLength(utf8Length: 2)
    case .withKeyword: return SourceLength(utf8Length: 4)
    case .semicolon: return SourceLength(utf8Length: 1)
    case .arrowSymbol: return SourceLength(utf8Length: 3)
    case .pipe: return SourceLength(utf8Length: 1)
    case .leftParen: return SourceLength(utf8Length: 1)
    case .recordKeyword: return SourceLength(utf8Length: 6)
    case .leftBrace: return SourceLength(utf8Length: 1)
    case .constructorKeyword: return SourceLength(utf8Length: 11)
    case .fieldKeyword: return SourceLength(utf8Length: 5)
    case .identifier(let text): return SourceLength(of: text)
    case .openKeyword: return SourceLength(utf8Length: 4)
    case .infixKeyword: return SourceLength(utf8Length: 5)
    case .underscore: return SourceLength(utf8Length: 1)
    case .infixlKeyword: return SourceLength(utf8Length: 6)
    }
  }
  public static func == (lhs: TokenKind, rhs: TokenKind) -> Bool {
    switch (lhs, rhs) {
    case (.eof, .eof): return true
    case (.period, .period): return true
    case (.dataKeyword, .dataKeyword): return true
    case (.colon, .colon): return true
    case (.rightParen, .rightParen): return true
    case (.equals, .equals): return true
    case (.forallSymbol, .forallSymbol): return true
    case (.whereKeyword, .whereKeyword): return true
    case (.importKeyword, .importKeyword): return true
    case (.rightBrace, .rightBrace): return true
    case (.letKeyword, .letKeyword): return true
    case (.typeKeyword, .typeKeyword): return true
    case (.backSlash, .backSlash): return true
    case (.infixrKeyword, .infixrKeyword): return true
    case (.unknown(let l),
          .unknown(let r)): return l == r
    case (.forallKeyword, .forallKeyword): return true
    case (.moduleKeyword, .moduleKeyword): return true
    case (.inKeyword, .inKeyword): return true
    case (.withKeyword, .withKeyword): return true
    case (.semicolon, .semicolon): return true
    case (.arrowSymbol, .arrowSymbol): return true
    case (.pipe, .pipe): return true
    case (.leftParen, .leftParen): return true
    case (.recordKeyword, .recordKeyword): return true
    case (.leftBrace, .leftBrace): return true
    case (.constructorKeyword, .constructorKeyword): return true
    case (.fieldKeyword, .fieldKeyword): return true
    case (.identifier(let l),
          .identifier(let r)): return l == r
    case (.openKeyword, .openKeyword): return true
    case (.infixKeyword, .infixKeyword): return true
    case (.underscore, .underscore): return true
    case (.infixlKeyword, .infixlKeyword): return true
    default: return false
    }
  }
}
